# Generated by Django 4.1.1 on 2024-08-19 15:16

from django.db import migrations, models, transaction


def migrate_tasks_attachments(apps, schema_editor):
    Attachment = apps.get_model('investments', 'Attachment')
    Task = apps.get_model('administrativelevels', 'Task')
    task_qs = Task.objects.exclude(models.Q(attachments=None) | models.Q(attachments=[]))

    attachments_list = list()
    for task in task_qs:
        for attachment_task in task.attachments:
            if 'attachment' in attachment_task and attachment_task['attachment'] is not None:
                if 'uri' in attachment_task['attachment'] and attachment_task['attachment']['uri'] is not None:
                    attachments_list.append(Attachment(
                        adm=task.activity.phase.village,
                        task=task,
                        url=attachment_task['attachment']['uri'],
                        type=attachment_task.get('type', 'Photo'),
                        name=attachment_task.get('name', None),
                        order=attachment_task.get('order', None)
                    ))

    total_rows = len(attachments_list)
    print(f"Total rows to process: {total_rows}")
    batch_size = 1000

    for start in range(0, total_rows, batch_size):
        end = min(start + batch_size, total_rows)
        print(f"Processing rows from {start} to {end}")

        with transaction.atomic():
            rows = attachments_list[start:end]
            Attachment.objects.bulk_create(rows)

def revert_migrate_tasks_attachments(apps, schema_editor):
    Attachment = apps.get_model('investments', 'Attachment')
    Task = apps.get_model('administrativelevels', 'Task')

    task_ids = list()
    tasks_list = list()
    attachment_qs = Attachment.objects.exclude(task=None)
    for attachment in attachment_qs:
        attachment_obj = {
            "name": attachment.name,
            "type": attachment.type,
            "order": attachment.order,
            "attachment": {
                "uri": attachment.url
            }
        }
        task_obj_aux = next((task for task in tasks_list if task['id'] == attachment.task.id), None)
        if task_obj_aux is None:
            task_ids.append(attachment.task.id)
            tasks_list.append({
                'id': attachment.task.id,
                'attachments': [attachment_obj]
            })
        else:
            task_obj_aux['attachments'].append(attachment_obj)

    task_qs = Task.objects.filter(id__in=task_ids)
    tasks_to_update = list()
    for task_obj in task_qs:
        my_item = next((item for item in tasks_list if item['id'] == task_obj.id), None)
        if my_item is not None:
            task_obj.attachments = my_item['attachments']
            tasks_to_update.append(task_obj)

    total_rows = len(tasks_to_update)
    print(f"Total rows to process: {total_rows}")
    batch_size = 1000

    for start in range(0, total_rows, batch_size):
        end = min(start + batch_size, total_rows)
        print(f"Processing rows from {start} to {end}")

        with transaction.atomic():
            rows = tasks_to_update[start:end]
            Task.objects.bulk_update(rows, ["attachments"])


class Migration(migrations.Migration):

    dependencies = [
        ('investments', '0012_investment_funded_by'),
    ]

    operations = [
        migrations.AddField(
            model_name='attachment',
            name='order',
            field=models.PositiveSmallIntegerField(default=0),
        ),
        migrations.AddField(
            model_name='attachment',
            name='name',
            field=models.CharField(max_length=255, null=True, blank=True),
        ),
        migrations.RunPython(migrate_tasks_attachments, revert_migrate_tasks_attachments)
    ]
